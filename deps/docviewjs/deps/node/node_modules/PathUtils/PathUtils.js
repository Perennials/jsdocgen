"use strict";

var Fs = require( 'fs' );
var Path = require( 'path' );

function _walk ( dir, relative,
	includePatterns, excludePatterns,
	callback, flags, recursive, excludeDirs,
	includeDirs, includeFiles, excludeFiles ) 
{

	var matchOr = PathUtils.matchOr;
	var entries = Fs.readdirSync( dir );
	for ( var i = 0, iend = entries.length; i < iend; ++i ) {
		var entry = entries[i];
		var path = dir + '/' + entry;
		entry = ( relative ? relative + '/' : '' ) + entry;
		var isdir = Fs.statSync( path ).isDirectory();

		if ( isdir ) {
			// check if dir is not matching an exclude pattern
			if ( excludeDirs === false || matchOr( entry, excludePatterns ) === false ) {

				// check if we are in recursive mode
				if ( recursive &&
					_walk( path, entry,
						includePatterns, excludePatterns,
						callback, flags, recursive, excludeDirs,
						includeDirs, includeFiles, excludeFiles
					) === false )
				{
					return false;
				}
				
				// check if dir is matching an include pattern
				if ( includeDirs && matchOr( entry, includePatterns ) ) {
					if ( callback( entry, isdir, path ) === false ) {
						return true;
					}
				}

			}
		}
		else {
			
			// check if file is matching an include pattern
			if ( includeFiles && matchOr( entry, includePatterns ) ) {
				// check if file is not matching an exclude pattern
				if ( excludeFiles === false || matchOr( entry, excludePatterns ) === false ) {
					if ( callback( entry, isdir, path ) === false ) {
						return true;
					}
				}
			}
		
		}
	}
}

var _regexCache = {};
//var _backSlashRegExp = ( Path.sep == '\\' ? /\\/g : null );
var _matchRegex = [
	/[\?\.\+\[\]\(\)\{\}\$\^\\\|]/g,
	/\*\*/g,
	/\*(?!\?)/g
];

/**
 * A compilation of file path related functions.
 * @def namespace PathUtils
 * @author Borislav Peev <borislav.asdf@gmail.com>
 */
var PathUtils = {

	/**
	 * Flag for {@see walk()} - include patterns match files only.
	 * @def const PathUtils.WALK_INCLUDE_FILES
	 */
	WALK_INCLUDE_FILES: 1,

	/**
	 * Flag for {@see walk()} - include patterns match dirs only.
	 * @def const PathUtils.WALK_INCLUDE_DIRS
	 */
	WALK_INCLUDE_DIRS: 2,

	/**
	 * Flag for {@see walk()} - include patterns match files and dirs.
	 * @def const PathUtils.WALK_INCLUDE_ALL
	 */
	WALK_INCLUDE_ALL: 3,

	/**
	 * Flag for {@see walk()} - exclude patterns match files only.
	 * @def const PathUtils.WALK_EXCLUDE_FILES
	 */
	WALK_EXCLUDE_FILES: 4,

	/**
	 * Flag for {@see walk()} - exclude patterns match dirs only.
	 * @def const PathUtils.WALK_EXCLUDE_DIRS
	 */
	WALK_EXCLUDE_DIRS: 8,

	/**
	 * Flag for {@see walk()} - exclude patterns match files and dirs.
	 * @def const PathUtils.WALK_EXCLUDE_ALL
	 */
	WALK_EXCLUDE_ALL: 12,

	/**
	 * Flag for {@see walk()} - work recursively.
	 * @def const PathUtils.WALK_RECURSIVE
	 */
	WALK_RECURSIVE: 16,

	/**
	 * Default flag for {@see walk()} - {@see WALK_INCLUDE_FILES} | {@see WALK_EXCLUDE_ALL} | {@see WALK_RECURSIVE}.
	 * @def const PathUtils.WALK_DEFAULT
	 */
	WALK_DEFAULT: 29,

	/**
	 * Flag for {@see listPath()} - includes files in the listing.
	 * @def const PathUtils.LIST_FILES
	 */
	LIST_FILES: 32,

	/**
	 * Flag for {@see listPath()} - includes directories in the listing.
	 * @def const PathUtils.LIST_DIRS
	 */
	LIST_DIRS: 64,

	/**
	 * Flag for {@see listPath()} - {@see LIST_FILES} | {@see LIST_DIRS}.
	 * @def const PathUtils.LIST_DIRS
	 */
	LIST_ALL: 96,

	/**
	 * Flag for {@see listPath()} - the entries are included in the listing with their full path.
	 * @def const PathUtils.LIST_FULL_PATH
	 */
	LIST_FULL_PATH: 128,

	/**
	 * Default flag for {@see listPath()} - {@see WALK_DEFAULT} | {@see LIST_ALL}.
	 * @def const PathUtils.LIST_DEFAULT
	 */
	LIST_DEFAULT: 125,


	/**
	 * Matches a path agains a wildcard pattern.
	 * The pattern format is simple: * matches everything but a slash (/), ** matches everything. Non greedy.
	 * Supports only forward slashes.
	 * Examples:
	 * <ul>
	 * <li>"*.cpp" will not match "dir/file.cpp"</li>
	 * <li>"**.cpp" will match "dir/file" in "dir/file.cpp"</li>
	 * <li>"**&#47;*.cpp" will match "dir" and "file" in "dir/file.cpp"</li>
	 * <li>"***.cpp" will match "dir/" and "file" in "dir/file.cpp"</li>
	 * <li>"***.cpp" will match "dir/subdir/" and "file" in "dir/subdir/file.cpp"</li>
	 * <li>"***.cpp" will match "" and "file" in "file.cpp"</li>
	 * </ul>
	 * @def function PathUtils.match ( path, pattern )
	 * @param string Path to match.
	 * @param string Wild card pattern.
	 * @return string[]|false The matches.
	 */
	match: function ( path, pattern ) {

		if ( pattern == '**' ) {
			return [ path ];
		}

		var regex = _regexCache[pattern];
		if ( regex === undefined ) {
			pattern = '^' + pattern
				.replace( _matchRegex[0], '\\$&' )
				.replace( _matchRegex[1], '(.*?)' )
				.replace( _matchRegex[2], '([^/]*?)' ) + '$';
			regex = new RegExp( pattern );
			_regexCache[pattern] = regex;
		}
		var ret = path.match( regex );
		return ret === null ? false : ret;
	},

	/**
	 * Performs a {@see match()} on a list of patterns.
	 * @def function PathUtils.matchAnd ( path, patterns )
	 * @param string Path to match.
	 * @param string[] List of patterns.
	 * @return bool true if all of the patterns match.
	 */
	matchAnd: function ( path, patterns ) {
		var match = PathUtils.match;
		for ( var i = 0, iend = patterns.length; i < iend; ++i ) {
			var pattern = patterns[i];
			if ( match( path, pattern ) === false ) {
				return false;
			}
		}
		return true;
	},

	/**
	 * Performs a {@see match()} on a list of patterns.
	 * @def function PathUtils.matchOr ( path, patterns )
	 * @param string Path to match.
	 * @param string[] List of patterns.
	 * @return bool true if all of the patterns match.
	 */
	matchOr: function ( path, patterns ) {
		var match = PathUtils.match;
		for ( var i = 0, iend = patterns.length; i < iend; ++i ) {
			var pattern = patterns[i];
			if ( match( path, pattern ) !== false ) {
				return true;
			}
		}
		return false;
	},

	/**
	 * Walks all entries (files, dirs or both) matching a pattern under a given path.
	 * @def function PathUtils.walkPath ( basepath, pattern, callback, flags )
	 * @param string Base directory where to look for matches
	 * @param string Pattern in the format supported by {@see match()}. Could be several patterns separated by |.
	 * A second list of exclude patterns can included separated by ":". "include|include..:exclude|exclude.."
	 * For example "*.php|*.js".
	 * @param callback Callback to be notified of each mathiching entry. Accepts three arguments -
	 * first is the path of the entry relative to the base path, second is boolean if the entry is a directory -
	 * true means directory, false means file, third is the full path of the entry.
	 * Return false from the callback to cancel further processing.
	 * @param int|undefined Flags specifying the matching behaviour. Defaults to {@see WALK_DEFAULT}.
	 * @return bool false on error.
	 * @todo Add a flag to select if the callback should be called for dirs before or after their content is walked
	 */
	walkPath: function ( basepath, pattern, callback, flags ) {
		flags = ( flags === undefined ? PathUtils.WALK_DEFAULT : flags );
		var pattern = pattern.split( ':' );
		var includePatterns = pattern[0].split( '|' );
		var excludePatterns = pattern.length > 1 ? pattern[1].split( '|' ) : null;
		var recursive = ( flags & PathUtils.WALK_RECURSIVE ) > 0;
		var excludeDirs = excludePatterns !== null && ( flags & PathUtils.WALK_EXCLUDE_DIRS ) > 0;
		var includeDirs = ( flags & PathUtils.WALK_INCLUDE_DIRS ) > 0;
		var includeFiles = ( flags & PathUtils.WALK_INCLUDE_FILES ) > 0;
		var excludeFiles = excludePatterns !== null && ( flags & PathUtils.WALK_EXCLUDE_FILES ) > 0;

		return _walk ( basepath, null,
			includePatterns, excludePatterns,
			callback, flags, recursive, excludeDirs,
			includeDirs, includeFiles, excludeFiles
		);

	},

	/**
	 * A wrapper for {@see walk()} that returns the list of the matches.
	 * @def function PathUtils.listPath ( basepath, pattern, flags )
	 * @param string {@see walk()}
	 * @param string {@see walk()}
	 * @param int|undefined Flags specifying the mathing behavior of both {@see walk()},
	 which is called internally and the function itself. Defaults to {@see LIST_DEFAULT}.
	 * @return array|false False on error, array with matched entries on success. The array could be empty.
	 */
	listPath: function ( basepath, pattern, flags ) {
		flags = ( flags === undefined ? PathUtils.LIST_DEFAULT : flags );
		var listFiles = ( flags & PathUtils.LIST_FILES ) > 0;
		var listDirs = ( flags & PathUtils.LIST_DIRS ) > 0;
		var listFullPath = ( flags & PathUtils.LIST_FULL_PATH ) > 0;
		var ret = [];
		if ( PathUtils.walkPath( basepath, pattern, function ( entry, isdir, path ) {
			if ( ( !isdir && listFiles ) || ( isdir && listDirs ) ) {
				ret.push( listFullPath ? path : entry );
			}
		}, flags ) === false ) {
			return false;
		}
		return ret;
	},

	/**
	 * Cleans a non empty directory of all files and directories matching a given pattern.
	 * The directory itself is not deleted. Non empty subdirectories will not be deleted.
	 * @def static function PathUtils.cleanDir ( path, pattern = "**" )
	 * @param string Directory path.
	 * @param string File pattern
	 * @return bool true on success, false on error.
	 */
	cleanDir: function ( path, pattern ) {
		if ( PathUtils.walkPath( path, pattern || '**', function ( entry, isdir, path ) {
			if ( isdir ) {
				Fs.rmdirSync( path );
			}
			else {
				Fs.unlinkSync( path );
			}
		}, PathUtils.WALK_INCLUDE_ALL | PathUtils.WALK_RECURSIVE ) === false ) {
			return false;
		}
		return true;
	},

	/**
	 * Deletes a non empty directory.
	 * @def static function PathUtils.removeDir ( path )
	 * @param string Directory path.
	 * @return bool true on success, false on error.
	 */
	removeDir: function ( path ) {
		if ( PathUtils.walkPath( path, '**', function ( entry, isdir, path ) {
			if ( isdir ) {
				return Fs.rmdirSync( path );
			}
			else {
				return Fs.unlinkSync( path );
			}
		}, PathUtils.WALK_INCLUDE_ALL | PathUtils.WALK_RECURSIVE ) === false ) {
			return false;
		}
		Fs.rmdirSync( path );
		return true;
	},

	/**
	Creates directory recusively.
	@def bool function PathUtils.createDir ( dir:string, mode:int|undefined )
	*/
	createDir: function ( dir, mode ) {
		var dirs = Path.normalize( dir ).split( Path.sep );
		var i = dirs[0].indexOf( ':' ) > 0 ? 1 : 0;
		var dir = i == 1 ? dirs[0] : '';
		for ( ; i < dirs.length; ++i ) {
			dir += Path.sep + dirs[i];
			if ( !Fs.existsSync( dir ) ) {
				Fs.mkdirSync( dir, mode );
			}
		}
		return Fs.existsSync( dir );
	}
};

module.exports = PathUtils;