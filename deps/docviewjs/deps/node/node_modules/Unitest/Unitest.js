"use strict";

(function ( exports, global ) {

	var _current = null;
	var _failed = 0;
	var _passed = 0;
	var _isNode = global.addEventListener === undefined;
	
	if ( _isNode ) {
		process.on( 'exit', function () {
			if ( _failed > 0 ) {
				process.exit( 1 );
			}
			else if ( _passed > 0 ) {
				console.log(
					( !global.UNITESTS_NOCOLOR ? '\u001b[32m' : '' ) +
					 _passed + ' unitests passed.' +
					( !global.UNITESTS_NOCOLOR ? '\u001b[0m' : '' )
				);
			}
		} );
	}


	function _getStackTrace () {
		var stack = null;
		try {
			var e = new Error();

			// ie only have .stack in the catch block
			if ( e.stack ) {
				// not ie flow
				stack = e.stack.substr( e.toString().length + 1 );
			}
			else {
				// ie flow
				throw e;
			}
		}
		catch ( e ) {
			// ie flow
			stack = e.stack ? e.stack.substr( e.toString().length + 1 ) : null;
		}
		return stack || null;
	}


	function _testFailed ( text, stack, offset ) {
		++_failed;
		var line = stack ? ' called @' + stack.split( '\n' )[offset].trim() : '';
		console.error(
			( _isNode && !global.UNITESTS_NOCOLOR ? '\u001b[33m' : '' ) +
			'Unitest failed: ' +
			( _isNode && !global.UNITESTS_NOCOLOR ? '\u001b[0m' : '' ) +
			( text ? text + ' in test ' : '' ) +
			( _isNode && !global.UNITESTS_NOCOLOR ? '\u001b[32m' : '' ) +
			( _current ? _current.name : '[Async test]' ) +
			( _isNode && !global.UNITESTS_NOCOLOR ? '\u001b[0m' : '' ) +
			line +
			( _isNode && !global.UNITESTS_NOCOLOR ? '\u001b[0m' : '' )
		);
	}

	/**
	 * Tests if a condition is met and throws an Error if it is not.
	 * @def static function test ( condition, text )
	 * @param any Will be tested with !condition
	 * @param string|undefined Description of the test.
	 * @throws Error
	 * @author Borislav Peev <borislav.asdf@gmail.com>
	 */
	function test ( condition, text ) {
		if ( !condition ) {
			_testFailed( text, _getStackTrace(), 2 );
		}
		else {
			++_passed;
		}
	}

	function _testeqText ( left, right, text ) {
		if ( !text ) {
			if ( !( typeof left == 'string' || left instanceof String ) || !( typeof right == 'string' || right instanceof String ) ) {
				left = JSON.stringify( left );
				right = JSON.stringify( right );
			}
			text = '\n---\n' + left + '\n--- equals ---\n' + right + '\n---\n';
		}
		return text;
	}

	/**
	 * Tests if two arguments are equal (==) and throws an Error if not.
	 * @def static function testrq ( left:mixed, right:mixed, text:string|undefined )
	 * @throws Error
	 * @author Borislav Peev <borislav.asdf@gmail.com>
	 */
	function testeq ( left, right, text ) {
		if ( left != right ) {
			text = _testeqText( left, right, text );
			_testFailed( text, _getStackTrace(), 2 );
		}
		else {
			++_passed;
		}
	}


	function _cmpArray ( left, right, cmpfunc ) {
		if ( left.length != right.length ) {
			return false;
		}
		for ( var i = left.length - 1; i >= 0; --i ) {
			if ( !cmpfunc( left[i], right[i] ) ) {
				return false;
			}
		}
		return true;
	}

	function _cmpObject ( left, right, cmpfunc ) {
		var keysleft = Object.keys( left );
		var keysright = Object.keys( right );
		if ( keysleft.length != keysright.length ) {
			return false;
		}
		keysleft = keysleft.sort();
		keysright = keysright.sort();
		for ( var i = keysleft.length - 1; i >= 0; --i ) {
			if ( !_cmpOne( keysleft[i], keysright[i] ) ) {
				return false;
			}
		}
		for ( var key in left ) {
			if ( !cmpfunc( left[key], right[key] ) ) {
				return false;
			}
		}
		return true;
	}

	function _cmpOne ( left, right ) {
		return left == right;
	}

	function _cmpDeep ( left, right ) {
		if ( left instanceof Array && right instanceof Array ) {
			return _cmpArray( left, right, _cmpDeep );
		}
		else if (
			left instanceof Object && Object.getPrototypeOf( left ) === Object.prototype &&
			right instanceof Object && Object.getPrototypeOf( right ) === Object.prototype
		) {
			return _cmpObject( left, right, _cmpDeep )
		}
		else {
			return _cmpOne( left, right );
		}
	}

	Unitest( 'Unitest.testeqdeep', function () {
		test( _cmpDeep( { a: 1, b: 2 }, { b: 2, a: 1 } ) );
		test( _cmpDeep( [ 1, 2 ], [ 1, 2 ] ) );
		test( !_cmpDeep( [ 1, 2 ], [ 2, 1 ] ) );
		test( _cmpDeep(
			[ { a: 1, b: { b: 2, a: [ 1, 2 ] } }, [ { b: 2, a: 1 } ] ],
			[ { a: 1, b: { b: 2, a: [ 1, 2 ] } }, [ { b: 2, a: 1 } ] ]
		) );
		test( !_cmpDeep(
			[ { a: 1, b: { b: 2, a: [ 1, 2 ] } }, [ { b: 2, a: 1 } ] ],
			[ { a: 1, b: { b: 2, a: [ 1, 1 ] } }, [ { b: 2, a: 1 } ] ]
		) );
		test( !_cmpDeep(
			[ { a: 1, b: { b: 2, a: [ 1, 2 ] } }, [ { b: 2, a: 2 } ] ],
			[ { a: 1, b: { b: 2, a: [ 1, 2 ] } }, [ { b: 2, a: 1 } ] ]
		) );
	} );

	/**
	 * Tests if two arguments are equal (==) and throws an Error if not.
	 * This function does deep comparison of arrays and objects.
	 * @def static function testrq ( left:mixed, right:mixed, text:string|undefined )
	 * @throws Error
	 * @author Borislav Peev <borislav.asdf@gmail.com>
	 */
	function testeqdeep ( left, right, text ) {
		if ( !_cmpDeep( left, right ) ) {
			text = _testeqText( left, right, text );
			_testFailed( text, _getStackTrace(), 2 );
		}
	}

	//private
	function runTest ( name, testcb ) {
		if ( name instanceof Function ) {
			testcb = name;
			name = '[unnamed test '+(_passed+_failed+1)+']';
		}
		_current = { name: name, test: test };
		try {
			testcb();
		}
		catch ( e ) {
			var text = e.toString();
			_testFailed( text, e.stack ? e.stack.substr( text.length + 1 ) : null, 0 );
		}
		finally {
			_current = null;
		}
	}

	/**
	 * Creates a test case. Test cases are executed when the document is loaded.
	 * @def static function Unitest ( test )
	 * @param function Function performing the the test case.
	 * @author Borislav Peev <borislav.asdf@gmail.com>
	 */

	/**
	 * Creates a test case. Test cases are executed when the document is loaded.
	 * @def static function Unitest ( name, test )
	 * @param string Name of the test case.
	 * @param function Function performing the the test case.
	 * @author Borislav Peev <borislav.asdf@gmail.com>
	 */
	function Unitest ( name, test ) {

		if ( global.UNITESTS === false || ( _isNode && global.UNITESTS === undefined ) ) {
			return false;
		}

		if ( _isNode || Unitest._loaded ) {
			
			runTest( name, test );
			return;
		
		}
		else if ( Unitest._tests === undefined ) {
			
			Unitest._loaded = false;
			Unitest._tests = [];
			
			global.addEventListener( 'load', function () {
				Unitest._loaded = true;

				if ( global.UNITESTS !== true ) {
					return false;
				}

				var tests = Unitest._tests;
				for ( var i = 0, iend = tests.length; i < iend; ++i ) {
					var test = tests[i];
					runTest( test[0], test[1] );
				}
			} );
		}
		
		Unitest._tests.push( [ name, test ] );
		
	}

	if ( !_isNode || global.UNITESTS === true ) {
		exports.log = function () { return console.log.apply( console, arguments ); };
		exports.test = test;
		exports.testeq = testeq;
		exports.testeqdeep = testeqdeep;
	}
	exports.Unitest = Unitest;

})(
	typeof global != 'undefined' ? global : this,
	typeof global != 'undefined' ? global : window
);